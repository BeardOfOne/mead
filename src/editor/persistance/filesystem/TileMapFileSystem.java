/**
 * Daniel Ricci {@literal <thedanny09@icloud.com>}
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

package editor.persistance.filesystem;

import java.awt.AlphaComposite;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.stream.Collectors;

import javax.imageio.ImageIO;
import javax.xml.bind.annotation.XmlRootElement;

import framework.communication.external.filesystem.AbstractFileSystem;
import framework.utils.io.ClassGenerator;
import framework.utils.io.JarPackage;
import framework.utils.io.Javac;
import framework.utils.io.Paths;
import framework.utils.logging.Tracelog;

import editor.models.TileLayerModel;
import editor.models.TileMapModel;
import editor.models.TileModel;
import generated.TileMapData;

/**
 * This file system represents persistent storage between the editor and another consumer
 * 
 * @author {@literal Daniel Ricci {@literal <thedanny09@icloud.com>}}
 *
 */
@XmlRootElement(name = "root")
public final class TileMapFileSystem extends AbstractFileSystem {

    /**
     * The name of all the files that are generated by this file system
     */
    private transient final String _fileName = "tilemap";

    /** 
     * Constructs a new instance of this class type
     * 
     * Note: This constructor is required for serialization purposes
     *
     */
    public TileMapFileSystem() {
    }

    /**
     * Constructs a new instance of this class type
     * 
     * @param file The path associated to this file system
     */
    public TileMapFileSystem(File file) {
        super(file);
    }

    /**
     * Generates a tile map representation of all the tile data loaded within the file system
     */
    public void generateTileMap() {

        // Get the list of tile map models.  The order of this list matters in this method
        // when performing operations
        List<TileMapModel> tileMapModels = getData(TileMapModel.class);

        // Calculate the width and height necessary to incorporate all tile map images
        int width = 0;
        int height = 0;
        for(TileMapModel tileMapModel : tileMapModels) {
            // Control the max height to remove unneeded white space. Obviously the width
            // will always increase.  Please note that you could also do this from it's height
            // and control the max-width.  Also, if you are very anal about white space you can
            // try and fill up the white spaces with an entire tile map
            width += tileMapModel.getColumns() * tileMapModel.getWidth();
            height = Math.max(height, tileMapModel.getRows() * tileMapModel.getHeight());
        }

        // Create a buffered image with the specified dimensions and get the graphics context associated to this image
        // Fill the entire image with the specified color for debug purposes
        BufferedImage image = new BufferedImage(width, height , BufferedImage.TYPE_INT_ARGB);
        Graphics2D graphics = image.createGraphics();
        
        // Create an alpha composite so that the initial background is fully transparent
        AlphaComposite composite = AlphaComposite.getInstance(AlphaComposite.CLEAR, 0.0f);
        graphics.setComposite(composite);
        
        // Draw the initial layout of the buffer
        graphics.fillRect(0, 0, width, height);
        
        // Set the composite back so that we can draw things over the transparent background
        graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER));
        
        // Go through the list of tile map models and from the generated list of tile map data, place the
        // image held by it into the image placeholder
        for(int i = 0, posX = 0, iSize = tileMapModels.size(); i < iSize; ++i) {

            // Generate the list of tile map data
            List<TileMapData> tileMapDatas = generateTileMapData(tileMapModels.get(i), posX);

            for(int j = 0, jSize = tileMapDatas.size(); j < jSize; ++j) {

                // Draw the portion of this image onto the image
                Image img = tileMapModels.get(i).getTiles().get(j).getImage();
                if(img != null) {
                    graphics.drawImage(
                            img,
                            tileMapDatas.get(j).getTopLeftX(), 
                            tileMapDatas.get(j).getTopLeftY(), 
                            tileMapDatas.get(j).getBottomRightX() - tileMapDatas.get(j).getTopLeftX(),
                            tileMapDatas.get(j).getBottomRightY() - tileMapDatas.get(j).getTopLeftY(),
                            null
                            );
                }

                // Include the tile map data into the file system
                write(tileMapDatas.get(j));
            }

            // Update the offset for the next tile map start position
            posX += tileMapModels.get(i).getColumns() * tileMapModels.get(i).getWidth();
        }

        try {
            // The output path where the image will be written to
            String outputPath = String.format("%s" + File.separator + "%s%s", _file.getParent(), Paths.filenameNoExtension(_file), EXTENSION_PNG);

            // Write to the tile map file as a "png" format the final buffer image contents
            ImageIO.write(image, Paths.cleanExtensionMark(EXTENSION_PNG, true), new File(outputPath));
        } 
        catch (Exception exception) {
            Tracelog.log(Level.SEVERE, true, exception);
        }
    }

    /**
     * Generates a list of data models from the list of provided tile map models.
     * 
     * @param tileMapModel The list of tile map models
     * @param offsetX The x-offset to set each tile map top-left position to
     * 
     * @return A list of tile map data's that represent that passed in models
     */
    private List<TileMapData> generateTileMapData(TileMapModel tileMapModel, int offsetX) {
        
        List<TileMapData> tileMapDatas = new ArrayList();
        List<TileLayerModel> tileLayers = getData(TileLayerModel.class);
        for(int i = 0; i < tileMapModel.getTiles().size(); ++i) {

            // Create the instance of the tile map data
            TileModel tileModel = tileMapModel.getTiles().get(i);
            
            if(tileModel.getLayers() == null || tileModel.getLayers().isEmpty()) {
                Tracelog.log(Level.INFO, true, "Cannot add tile model " + tileModel.toString() + " because no layers were associated to it");
                continue;
            }
            
            TileMapData data = new TileMapData(
                tileModel.getUUID(),
                tileModel.getName(), 
                tileModel.getFriendlyName(),
                tileLayers.stream().filter(z -> tileModel.getLayers().contains(z.getUUID())).map(z -> z.getUUID()).collect(Collectors.toList())
            );

            // Set the top-left point
            data.setPositionTopLeft(
                offsetX + (tileMapDatas.size() % tileMapModel.getColumns()) * tileModel.getWidth(),
                (tileMapDatas.size() / tileMapModel.getColumns()) * tileModel.getHeight()
            );

            // Set the bottom-right point
            data.setPositionBottomRight(
                data.getTopLeftX() + tileModel.getWidth(),
                data.getTopLeftY() + tileModel.getHeight()
            );

            tileMapDatas.add(data);
        }

        return tileMapDatas;
    }

    /**
     * Generates and returns the contents of the lookup file
     * 
     * @return The generated file
     */
    private File generateDataLookupFile() {

        // Create a logical file for storing the generated source content
        // and specify that the file should be deleted when the application terminates
        File dataLookupFile = new File(System.getProperty("java.io.tmpdir") + "DataLookup" + EXTENSION_JAVA);
        dataLookupFile.deleteOnExit();

        // Create a new class generator with the specified class name and the specified package name
        ClassGenerator classGenerator = new ClassGenerator(TileMapData.class.getPackage().getName(), Paths.filenameNoExtension(dataLookupFile));

        // Holds a reference to the data stored within the file system, this will be used
        // when generating the data lookup enums below
        List<TileLayerModel> tileLayers = this.getData(TileLayerModel.class);
        List<TileMapModel> tileMapModels =  this.getData(TileMapModel.class);

        List<TileModel> allTileModels = tileMapModels.stream().flatMap(z -> z.getTiles().stream()).collect(Collectors.toList());
        for(TileLayerModel tileLayerModel : tileLayers) {
            
            List<TileModel> layerTileModels = new ArrayList();
            for(TileModel tileModel : allTileModels) {
                if(tileModel.getLayers().contains(tileLayerModel.getUUID())) {
                    layerTileModels.add(tileModel);
                }
            }
            
            if(!layerTileModels.isEmpty()) {
                classGenerator.appendEnum(tileLayerModel.getName(), layerTileModels);    
            }
        }
        
        // Create another enum entry for the list of layers
        classGenerator.appendEnum("LAYER", tileLayers.stream().filter(z -> !z.getName().isEmpty()).collect(Collectors.toList()));

        // Write the contents to the .java file within the temporary directory.  It will
        // soon get compiled programmatically, and will be removed when the JVM releases
        // its resources
        classGenerator.write(dataLookupFile);

        // Return the file back
        return dataLookupFile;
    }

    @Override public String serialize() {

        // Create a new jar package
        JarPackage jarPackage = new JarPackage(String.format(
                "%s" + File.separator + "%s", 
                _file.getParent(), 
                _fileName + EXTENSION_JAR
                ));

        // Add an entry for the tile map data .class file that would 
        // have been generated at compilation time
        jarPackage.addEntry(
                new File(Paths.getClassLocation(TileMapData.class)), 
                Paths.packageToPath(TileMapData.class)
                );

        try {
            // Compile the temporary file that was generated and get a reference to its
            // list of compiled files
            List<File> compiledFiles = Javac.compile(generateDataLookupFile().toURI());

            // Go through the list of compiled .class files and add each of them
            // as an entry into the .jar construct
            for(File file : compiledFiles) {
                jarPackage.addEntry(file, Paths.packageToPath(TileMapData.class));
            }
        }
        catch(Exception exception) {
            Tracelog.log(Level.SEVERE, true, exception);
            return null;
        }

        // Close the jar package stream
        jarPackage.close();

        // Cleanup the file system, ensuring that only the tile map entity objects exist
        // so that this is all that is actually serialized.  This is done because everything
        // else prior is needed to perform other operations, but in the end the only thing
        // that is worth serializing is the tile map data
        removeDataExcept(TileMapData.class);

        // Serialize this class's contents
        return super.serialize();
    }
}	